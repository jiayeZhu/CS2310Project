import java.io.*;
import java.net.Socket;
import java.text.SimpleDateFormat;
import java.util.*;

public class CreateGesture {

    // scope of this component
    private static final String SCOPE = "SIS.Scope1";
    // name of this component
    private static final String NAME = "Gesture";
    // messages types that can be handled by this component
    private static final List<String> TYPES = new ArrayList<String>(
            Arrays.asList("Setting", "Confirm"));
    // socket for connection to SISServer
    static Socket universal;
    // message writer
    static MsgEncoder encoder;
    // message reader
    static MsgDecoder decoder;
    private static int port = 53217;
    private static int refreshRate = 1000;
    private static Date startDate = new Date(), endDate = new Date();

    private static Timer timer = new Timer();

    // shared by all kinds of records that can be generated by this component
    private static KeyValueList record = new KeyValueList();
    // shared by all kinds of alerts that can be generated by this component
    private static KeyValueList alert = new KeyValueList();

    private static GestureReading reading = new GestureReading();

    private static SimpleDateFormat format = new SimpleDateFormat(
            "yyyy-MM-dd HH:mm:ss");
    private static Queue<String> mockupData;
    /*
     * Main program
     */
    public static void main(String[] args) {
        while (true) {
            try {

                // try to establish a connection to SISServer
                universal = connect();

                // bind the message reader to inputstream of the socket
                decoder = new MsgDecoder(universal.getInputStream());
                // bind the message writer to outputstream of the socket
                encoder = new MsgEncoder(universal.getOutputStream());

                /*
                 * construct a Connect message to establish the connection
                 */
                KeyValueList conn = new KeyValueList();
                conn.putPair("Scope", SCOPE);
                conn.putPair("MessageType", "Connect");
                conn.putPair("Role", "Basic");
                conn.putPair("Name", NAME);
                encoder.sendMsg(conn);

                initRecord();

                // KeyValueList for inward messages, see KeyValueList for
                // details
                KeyValueList kvList;

                while (true) {
                    // attempt to read and decode a message, see MsgDecoder for
                    // details
                    kvList = decoder.getMsg();

                    // process that message
                    ProcessMsg(kvList);
                }

            } catch (Exception e) {
                // if anything goes wrong, try to re-establish the connection
                System.err.println(e.getMessage());
                try {
                    // wait for 1 second to retry
                    Thread.sleep(1000);
                } catch (InterruptedException e2) {
                }
                System.out.println("Try to reconnect");
                try {
                    universal = connect();
                } catch (IOException e1) {
                }
            }
        }
    }

    /*
     * used for connect(reconnect) to SISServer
     */
    static Socket connect() throws IOException {
        Socket socket = new Socket("127.0.0.1", port);
        return socket;
    }

    private static void initRecord() {
        record.putPair("Scope", SCOPE);
        record.putPair("MessageType", "Reading");
        record.putPair("Sender", NAME);

        // Receiver may be different for each message, so it doesn't make sense
        // to set here
        // record.putPair("Receiver", "");

        alert.putPair("Scope", SCOPE);
        alert.putPair("MessageType", "Alert");
        alert.putPair("Sender", NAME);
        alert.putPair("Purpose", "GestureAlert");

        // Receiver may be different for each message, so it doesn't make sense
        // to set here
        // alert.putPair("Receiver", "");
    }

    private static void componentTask() {
        try {
            //TODO: implement the collect() with mock up data
            collect();
            if (reading.needHelp) {
                //send alert to Controller and Uploader
                reading.date = System.currentTimeMillis();
                alert.putPair("NeedHelp", reading.needHelp+"");
                alert.putPair("Date",reading.date+"");
                alert.removePair("Receiver");
                alert.putPair("Receiver","SuperController");
                encoder.sendMsg(alert);
                System.out.println(alert.toString());
            } else {
                System.out.println("=== Patient doesn't need help. ===");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void ProcessMsg(KeyValueList kvList) throws Exception {

        String scope = kvList.getValue("Scope");
        if (!SCOPE.startsWith(scope)) {
            return;
        }

        String messageType = kvList.getValue("MessageType");
        if (!TYPES.contains(messageType)) {
            return;
        }

        String sender = kvList.getValue("Sender");

        String receiver = kvList.getValue("Receiver");

        String purpose = kvList.getValue("Purpose");

        switch (messageType) {
            case "Confirm":
                System.out.println("Connect to SISServer successful.");
                break;
            case "Setting":
                if (receiver.equals(NAME)) {
                    System.out.println("Message from " + sender);
                    System.out.println("Message type: " + messageType);
                    System.out.println("Message Purpose: " + purpose);
                    switch (purpose) {

                        case "Activate":
                            String rRate = kvList.getValue("RefreshRate");
                            String sDate = kvList.getValue("StartDate");
                            String eDate = kvList.getValue("EndDate");

                            if (rRate != null && !rRate.equals("")) {
                                refreshRate = Integer.parseInt(rRate);
                            }

                            if (sDate != null && !sDate.equals("") && eDate != null
                                    && !eDate.equals("")) {
                                startDate.setTime(Long.parseLong(sDate));
                                endDate.setTime(Long.parseLong(eDate));
                            }

                            try {
                                timer.cancel();
                                timer = new Timer();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            timer.schedule(new TimerTask() {

                                @Override
                                public void run() {
                                    // TODO Auto-generated method stub
                                    if (System.currentTimeMillis() - endDate.getTime() > 0) {
                                        cancel();
                                    } else {
//                                        System.out.println(" === Gesture component Task Start === ");
                                        componentTask();
//                                        System.out.println(" === Gesture component Task Finished === ");
                                    }
                                }
                            }, startDate, refreshRate);
                            System.out.println("Algorithm Activated");
                            break;

                        case "Kill":
                            try {
                                timer.cancel();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            System.exit(0);
                            break;

                        case "Deactivate":
                            try {
                                timer.cancel();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            System.out.println("Algorithm Deactivated");
                            break;
                    }
                }
                break;
        }
    }

    private static void collect() throws Exception {
        if(mockupData == null){
            mockupData = new LinkedList<>();
            //read in data
            File dataFile = new File("mockup.txt");
            FileReader fr = new FileReader(dataFile);
            BufferedReader br = new BufferedReader(fr);
            String line;
            while((line = br.readLine()) != null){
                if(line.startsWith("#")) continue; //line start with # is comment line
                if(!line.contains("\t")) continue; //lines don't contain \t are invalid
                mockupData.offer(line);
            }
            collect();
        }else if (mockupData.size() != 0){
            //read one record
            String[] parts = mockupData.poll().split("\t");
            //record format:
            //parts[0]: date in long
            //parts[1]: gesture detected or not in boolean
            try {
                reading.date = Long.parseLong(parts[0]);
                reading.needHelp = Boolean.parseBoolean(parts[1]);
            }catch (Exception e) {
                System.err.println("parsing mockup data failed");
            }
        }else{
            System.out.println("==== mockup data is used up ====");
        }
    }

}

class GestureReading {
    boolean needHelp;
    long date;
}
